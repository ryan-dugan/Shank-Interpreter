package shank_interpreter;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

import shank_interpreter.InvalidCharException;
import shank_interpreter.Token.tokenType;

/**
 * This Lexer class accepts a string and uses a state machine to iterate over
 * the input string and create tokens. It throws an exception for invalid
 * characters and holds a list of tokens.
 * 
 * @author Ryan Dugan
 */
public class Lexer {

	/**
	 * An enumeration representing the states of the state machine.
	 */
	public enum State {
		START, IDENTIFIER, NUMBER, DECIMAL, PUNCTUATION, STRINGLITERAL, CHARACTERLITERAL, COMMENT
	}

	/**
	 * The current state of the state machine.
	 */
	State currentState;

	/**
	 * A list of tokens generated by the lexer.
	 */
	ArrayList<Token> tokens = new ArrayList<Token>();
	
	/**
	 * The the number of the current line being lexed.
	 */
	int lineNumber = 1;

	/**
	 * Hashmap holding list of known Shank keywords.
	 */
	HashMap<String, tokenType> known_words = new HashMap<String, tokenType>();
	{
		known_words.put("while", tokenType.WHILE);
		known_words.put("for", tokenType.FOR);
		known_words.put("from", tokenType.FROM);
		known_words.put("to", tokenType.TO);
		known_words.put("of", tokenType.OF);
		known_words.put("constants", tokenType.CONSTANTS);
		known_words.put("variables", tokenType.VARIABLES);
		known_words.put("integer", tokenType.INTEGER);
		known_words.put("real", tokenType.REAL);
		known_words.put("boolean", tokenType.BOOLEAN);
		known_words.put("char", tokenType.CHAR);
		known_words.put("string", tokenType.STRING);
		known_words.put("array", tokenType.ARRAY);
		known_words.put("define", tokenType.DEFINE);
		known_words.put("if", tokenType.IF);
		known_words.put("then", tokenType.THEN);
		known_words.put("elsif", tokenType.ELSIF);
		known_words.put("else", tokenType.ELSE);
		known_words.put("repeat", tokenType.REPEAT);
		known_words.put("until", tokenType.UNTIL);
		known_words.put("mod", tokenType.MOD);
		known_words.put("var", tokenType.VAR);
		known_words.put("true", tokenType.TRUE);
		known_words.put("false", tokenType.FALSE);
	}

	/**
	 * Hashmap holding list of known Shank punctuation.
	 */
	HashMap<String, tokenType> known_punct = new HashMap<String, tokenType>();
	{
		known_punct.put("=", tokenType.EQUALS);
		known_punct.put("!=", tokenType.NOTEQUAL);
		known_punct.put(">", tokenType.GREATER);
		known_punct.put("<", tokenType.LESS);
		known_punct.put(">=", tokenType.GREATEROREQUAL);
		known_punct.put("<=", tokenType.LESSOREQUAL);
		
		known_punct.put("+", tokenType.PLUS);
		known_punct.put("-", tokenType.MINUS);
		known_punct.put("*", tokenType.MULTIPLY);
		known_punct.put("/", tokenType.DIVIDE);
		
		known_punct.put("!", tokenType.NOT);
		known_punct.put("&&", tokenType.AND);
		known_punct.put("||", tokenType.OR);
		
		known_punct.put(":=", tokenType.ASSIGNMENT);
		known_punct.put(":", tokenType.COLON);
		known_punct.put(";", tokenType.SEMICOLON);
		known_punct.put(",", tokenType.COMMA);
		
		known_punct.put("(", tokenType.LPAREN);
		known_punct.put(")", tokenType.RPAREN);
		known_punct.put("{", tokenType.LCBRACK);
		known_punct.put("}", tokenType.RCBRACK);
		known_punct.put("]", tokenType.RBRACK);
		known_punct.put("[", tokenType.LBRACK);

	}
	
	int prevIndent = 0;
	
	
	/**
	 * Accepts a string and tokenizes it using a state machine.
	 * 
	 * @param s The string to be tokenized.
	 * @throws Exception
	 */
	public void lex(String s) throws Exception {

		int curIndent = getIndent(s);
		lineNumber++;
		
		/**
		 * This block outputs the correct number of indent or dedent tokens at the beginning of each new line.
		 */
		for(int i = 0; i < curIndent - prevIndent; i++)
			tokens.add(new Token(tokenType.INDENT, "", lineNumber));
		for(int i = 0; i < prevIndent - curIndent; i++)
			tokens.add(new Token(tokenType.DEDENT, "", lineNumber));
		prevIndent = curIndent;
		
		/**
		 * A char array to store the input string and an accumulator variable.
		 */
		char[] chars = s.toCharArray();
		String acc = "";
		int index = 0;

		currentState = State.START;	

		/**
		 * For loop to loop through each character in the char array.
		 */
		for (char c : chars) {
			
			/**
			 * Switch statement with cases representing each state of the state machine.
			 */
			switch (currentState) {
			
			/**
			 * State START of state machine.
			 */
			case START:
				// if char is a-zA-Z, accumulate c and go to state IDENTIFIER
				if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) {
					acc += c;
					currentState = State.IDENTIFIER;
				}
				// if char is 0-9, accumulate c and go to state NUMBER
				else if (c >= '0' && c <= '9') {
					acc += c;
					currentState = State.NUMBER;
				}
				// if char is a decimal point, accumulate c and go to state DECIMAL
				else if (c == '.') {
					acc += c;
					currentState = State.DECIMAL;
				}				

				// if char is a symbol, accumulate c and go to state PUNCTUATION
				else if (isSymbol(c)) {
					currentState = State.PUNCTUATION;
					acc += c;
				}
				// if char is a space or an indent, ignore
				else if (c == ' ' || c == '\t') {
					currentState = State.START;
					acc = "";	
				}
				// if char is an apostrophe, go to state CHARACTERLITERAL
				else if(c == '\'') {
					currentState = State.CHARACTERLITERAL;
					acc = "";				
				}
				// if char is a quotation mark, go to state STRINGLITERAL
				else if(c == '\"') {
					currentState = State.STRINGLITERAL;
					acc = "";
				}
				// if char is a left bracket, go to state COMMENT
				else if(c == '{') {
					currentState = State.COMMENT;
					acc = "";
				}
				// if char is an unknown character, throw InvalidCharException
				else {
					throw new InvalidCharException("Line " + lineNumber + "; Invalid character in START state: " + c);
				}

				break;

			/**
			 * State IDENTIFIER of state machine.
			 */
			case IDENTIFIER:

				// if char is a-zA-Z0-9, stay in state IDENTIFIER
				if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9')) {
					currentState = State.IDENTIFIER;
					acc += c;
				}

				// if char is anything else, add token and reset accumulator
				else {

					if (known_words.containsKey(acc.toLowerCase())) {
						tokens.add(new Token(known_words.get(acc.toLowerCase()), "", lineNumber));
					}
					else {
						tokens.add(new Token(tokenType.IDENTIFIER, acc, lineNumber));
					}
					
					currentState = State.START;
					acc = "";
					
					if (Character.isLetter(c)) {
			            acc += c;
			            currentState = State.IDENTIFIER;
			        }
					else if (Character.isDigit(c)) {
			            acc += c;
			            currentState = State.NUMBER;
			        }
					else if (c == '.') {
			            acc += c;
			            currentState = State.DECIMAL;
			        }
					else if (c == ' ' || c == '\t') {
						currentState = State.START;
						acc = "";
					}
					else if (isSymbol(c)) {
						currentState = State.PUNCTUATION;
						acc += c;
					}
					else
						throw new InvalidCharException("Line " + lineNumber + "; Invalid Character in IDENTIFIER state: " + c);

				}

				break;

			/**
			 * State DECIMAL of state machine.
			 */
			case DECIMAL:

				// if char is 0-9, stay in state 3
				if (c >= '0' && c <= '9') {
					currentState = State.DECIMAL;
					acc += c;
				}

				// if char is anything else, add token and reset accumulator
				else {
					tokens.add(new Token(tokenType.NUMBER, acc, lineNumber));
					
					currentState = State.START;
					acc = "";
					
					if (Character.isLetter(c)) {
			            acc += c;
			            currentState = State.IDENTIFIER;
			        }
					else if (Character.isDigit(c)) {
			            acc += c;
			            currentState = State.NUMBER;
			        }
					else if (c == '.') {
			            acc += c;
			            currentState = State.DECIMAL;
			        }
					else if (c == ' ' || c == '\t') {
						currentState = State.START;
						acc = "";
					}
					else if (isSymbol(c)) {
						currentState = State.PUNCTUATION;
						acc += c;
					}
					else
						throw new InvalidCharException("Line " + lineNumber + "; Invalid Character in DECIMAL state: " +c);
				}

				break;

			/**
			 * State NUMBER of state machine.
			 */
			case NUMBER:

				// if char is 0-9, stay in state 4
				if (c >= '0' && c <= '9') {
					currentState = State.NUMBER;
					acc += c;
				}

				// if char is a decimal point, go to state 3
				else if (c == '.') {
					currentState = State.DECIMAL;
					acc += c;
				}

				// if char is anything else, add token and reset accumulator
				else {
					tokens.add(new Token(tokenType.NUMBER, acc, lineNumber));
					
					currentState = State.START;
					acc = "";
					
					if (Character.isLetter(c)) {
			            acc += c;
			            currentState = State.IDENTIFIER;
			        }
					else if (Character.isDigit(c)) {
			            acc += c;
			            currentState = State.NUMBER;
			        }
					else if (c == '.') {
			            acc += c;
			            currentState = State.DECIMAL;
			        }
					else if (c == ' ' || c == '\t') {
						currentState = State.START;
						acc = "";
					}
					else if (isSymbol(c)) {
						currentState = State.PUNCTUATION;
						acc += c;
					}
					else
						throw new InvalidCharException("Line " + lineNumber + "; Invalid Character in NUMBER state: " +c);
				}

				break;

			/**
			 * PUNCTUATION state of the state machine.
			 */
			case PUNCTUATION:

				if (isSymbol(c)) {
					if (acc.isEmpty() || known_punct.containsKey(acc + c)) {
			            acc += c;
			        } else {
			            tokens.add(new Token(known_punct.get(acc), acc, lineNumber));
			            acc = "" + c;
			        }
			        currentState = State.PUNCTUATION;
				}
				else {
					if (!acc.isEmpty()) {
			            tokens.add(new Token(known_punct.get(acc), acc, lineNumber));
			            acc = "";
			        }
			        currentState = State.START;
					
					if (Character.isLetter(c)) {
			            acc += c;
			            currentState = State.IDENTIFIER;
			        }
					else if (Character.isDigit(c)) {
			            acc += c;
			            currentState = State.NUMBER;
			        }
					else if (c == '.') {
			            acc += c;
			            currentState = State.DECIMAL;
			        }
					else if (c == ' ' || c == '\t') {
						currentState = State.START;
						acc = "";
					}
					else if (isSymbol(c)) {
						currentState = State.PUNCTUATION;
						acc += c;
					}
					else
						throw new InvalidCharException("Line " + lineNumber + "; Invalid Character in PUNCTUATION state: " +c);
					
				}

				break;
			
			/**
			 * CHARACTERLITERAL state of the state machine.
			 */
			case CHARACTERLITERAL:

				if(acc.length() == 0 && c != '\'') {
					acc += c;
					currentState = State.CHARACTERLITERAL;
				}
				else if(acc.length() > 0 && c != '\'') {
					throw new Exception("Line " + lineNumber + "; Invalid Character in CHARACTERLITERAL state; expected \"\'\", saw " + c);
				}
				else {
					tokens.add(new Token (tokenType.CHARACTERLITERAL, acc, lineNumber));
					currentState = State.START;
					acc = "";
				}
				
				break;
			
			/**
			 * STRINGLITERAL state of the state machine.
			 */
			case STRINGLITERAL:
				
				if(c != '\"') {
					acc += c;
					currentState = State.STRINGLITERAL;
				}
				else if(acc.length() > 0 && c != '\"') {
					throw new Exception("Line " + lineNumber + "; Invalid Character in STRINGLITERAL state; expected \"\"\", saw " + c);
				}
				else {
					tokens.add(new Token (tokenType.STRINGLITERAL, acc, lineNumber));
					currentState = State.START;
					acc = "";
				}
				
				break;
				
			/**
			 * COMMENT state of the state machine.
			 */
			case COMMENT:
				
				if(c != '}') {
					currentState = State.COMMENT;
				}
				else {
					currentState = State.START;
				}
				
				break;
				
			}
		}

		/**
		 * Add the accumulated token of the appropriate type when the end of the string
		 * has been reached, so long as accumulator variable is not empty.
		 */
		if (!acc.isEmpty()) {

			if (Character.isDigit(acc.charAt(0)) || acc.charAt(0) == '.')
				tokens.add(new Token(tokenType.NUMBER, acc, lineNumber));

			else if(Character.isLetter(acc.charAt(0))) {
				if (known_words.containsKey(acc.toLowerCase()))
					tokens.add(new Token(known_words.get(acc.toLowerCase()), "", lineNumber));
				else
					tokens.add(new Token(tokenType.IDENTIFIER, acc, lineNumber));
			}
			
			else if (isSymbol(acc.charAt(0)))
				tokens.add(new Token(known_punct.get(acc), acc, lineNumber));

		}
		
		

		/**
		 * Add the 'ENDOFLINE' token when the end of the string has been reached.
		 */
		tokens.add(new Token(tokenType.ENDOFLINE, null, lineNumber));
		
		
	}

	/**
	 * Returns the list of tokens.
	 * 
	 * @return the list of tokens
	 */
	public List<Token> getTokens() {
		return tokens;
	}

	/**
	 * Checks to see if character is a symbol we care about.
	 */
	public boolean isSymbol(char c) {

		String specialCharacters = "+-*/!&|=><:;(),[]";

		return specialCharacters.indexOf(c) != -1;

	}
	
	/**
	 * Returns the number of indents at the beginning of each new line.
	 * 
	 * @param s
	 * 				the string to be lexed
	 * @return
	 * 				number of indents at the beginning of the line
	 */
	public int getIndent(String s) {
		int i = 0;
		for(char c : s.toCharArray()) {
			if(c == ' ')
				i++;
			else if(c == '\t')
				i+=4;
			else
				return i/4;
		}
		return 0;
	}

}
